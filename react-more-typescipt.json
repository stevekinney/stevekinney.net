[
  {
    "id": "react-19-typescript-mental-models",
    "title": "React 19 + TypeScript Mental Models",
    "description": "Build a rock‑solid mental model—JSX as function calls, compile‑time vs runtime, and why types are executable design docs.",
    "learningObjectives": [
      "Map JSX to function calls and understand how generics flow through components",
      "Differentiate compile‑time guarantees from runtime validation",
      "Adopt public‑API thinking for components and hooks",
      "Set pragmatic expectations for TypeScript’s soundness and ergonomics"
    ],
    "outline": [
      {
        "section": "JSX as function calls",
        "topics": ["JSX → React.createElement", "Generic components as generic function calls"],
        "examples": "Make a generic <List<T>> that infers T from items and renderItem.",
        "flow": "Start with JSX sugar → expand to function calls → show inference on generic props. "
      },
      {
        "section": "Contracts, compile time, runtime",
        "topics": ["Props as public API", "Type guarantees vs. runtime data", "Trust boundaries"],
        "examples": "Fetch JSON as unknown, validate with Zod, then render typed UI.",
        "flow": "Define ‘contract’ → show failure without runtime validation → add schema parsing. "
      }
    ]
  },
  {
    "id": "tsconfig-for-react-19",
    "title": "Tsconfig That Loves React 19",
    "description": "Dial in strictness, module resolution, JSX settings, and project references—fast builds without losing safety.",
    "learningObjectives": [
      "Enable the strictness suite that catches real bugs",
      "Choose bundler vs nodeNext module resolution",
      "Use isolatedModules with modern bundlers",
      "Adopt project references for monorepos"
    ],
    "outline": [
      {
        "section": "Strictness that pays",
        "topics": [
          "strict, noUncheckedIndexedAccess",
          "exactOptionalPropertyTypes",
          "noImplicitOverride"
        ],
        "examples": "Flip each flag and fix newly surfaced issues in a small app.",
        "flow": "Explain each flag → apply → measure DX and correctness. "
      },
      {
        "section": "Builds, modules, and JSX",
        "topics": ["jsx: react-jsx", "moduleResolution: bundler", "noEmit + bundler pipeline"],
        "examples": "Vite + tsc --noEmit pipeline and CI type-check job.",
        "flow": "Scaffold → configure → split transpile vs types. "
      }
    ]
  },
  {
    "id": "typescript-without-trying",
    "title": "Using TypeScript Without Even Trying",
    "description": "Let inference do the heavy lifting—see how much TypeScript you get “for free” in everyday React files.",
    "learningObjectives": [
      "Read inferred function and component types from your editor",
      "Recognize when explicit annotations are needed",
      "See how nullability and unions appear from control flow"
    ],
    "outline": [
      {
        "section": "Leaning on inference",
        "topics": ["Return type inference", "JSX.Element | null via control flow"],
        "examples": "Convert a .jsx component to .tsx and inspect inferred types.",
        "flow": "Start plain → hover types → introduce branches → see unions. "
      }
    ]
  },
  {
    "id": "migrating-from-proptypes",
    "title": "Migrating from PropTypes to TypeScript",
    "description": "Replace runtime warnings with compile‑time safety—move prop validation into your types and editor.",
    "learningObjectives": [
      "Convert PropTypes to TypeScript props",
      "Type onChange and other DOM events correctly",
      "Use optional props with sensible defaults"
    ],
    "outline": [
      {
        "section": "From PropTypes to props types",
        "topics": ["Inline prop annotation", "Extracted NameBadgeProps"],
        "examples": "Port the name‑badges Controls and NameBadge components.",
        "flow": "Change file extension → add prop types → remove PropTypes. "
      },
      {
        "section": "Typing events and optional props",
        "topics": [
          "ChangeEventHandler<HTMLInputElement>",
          "Optional props via ?",
          "Defaults in destructuring"
        ],
        "examples": "Typed ControlPanel with onChange and optional greeting.",
        "flow": "Hover to discover types → replace any → verify compile errors vanish. "
      }
    ]
  },
  {
    "id": "typing-children-correctly",
    "title": "Typing Children and When to Use ReactNode",
    "description": "Children can be strings, elements, arrays—learn the correct types and helpers without guesswork.",
    "learningObjectives": [
      "Choose ReactNode over narrower alternatives",
      "Use PropsWithChildren idiomatically",
      "Spot React.ReactChildren vs ReactNode gotchas"
    ],
    "outline": [
      {
        "section": "What counts as children",
        "topics": ["ReactNode vs ReactElement vs JSX.Element", "Single vs multiple children"],
        "examples": "Re‑type a Box component to accept all valid children.",
        "flow": "Try wrong types → compare behaviors → settle on ReactNode. "
      },
      {
        "section": "Helpers",
        "topics": ["PropsWithChildren<P>", "ComponentPropsWithoutRef for pass‑through"],
        "examples": "Box with optional color prop using PropsWithChildren<BoxProps>.",
        "flow": "Introduce helpers → refactor → verify DX in editor. "
      }
    ]
  },
  {
    "id": "common-prop-shapes",
    "title": "Common Prop Shapes and Patterns",
    "description": "Get fluent with primitives, arrays, objects, unions, indexed types, and functions in your props.",
    "learningObjectives": [
      "Model common shapes with type aliases",
      "Use Record and index signatures safely",
      "Type function props including event handlers"
    ],
    "outline": [
      {
        "section": "From primitives to records",
        "topics": ["string | number | boolean", "Item[] and Record<string, Item>"],
        "examples": "Refactor a contrived component using Item and Item[].",
        "flow": "Start basic → introduce objects → add index signatures. "
      },
      {
        "section": "Function props",
        "topics": ["onClick signatures", "MouseEvent<HTMLButtonElement>"],
        "examples": "Type a Button with properly typed onClick and label.",
        "flow": "Show inline vs extracted function types → pick a style. "
      }
    ]
  },
  {
    "id": "dom-and-react-event-types",
    "title": "DOM and React Event Types Without Tears",
    "description": "Never guess again—use React’s built‑in event types for forms, mouse, keyboard, and more.",
    "learningObjectives": [
      "Choose the right React.*Event types per element",
      "Use ChangeEventHandler vs ChangeEvent",
      "Understand target vs currentTarget"
    ],
    "outline": [
      {
        "section": "Event type tour",
        "topics": [
          "Change, Form, Mouse, Keyboard, Pointer",
          "Typing handlers you pass through to DOM"
        ],
        "examples": "Type a form with input/select/textarea change handlers.",
        "flow": "List common handlers → apply to a small form. "
      }
    ]
  },
  {
    "id": "usestate-inference-and-traps",
    "title": "useState Inference—Primitives, Unions, and the Empty Case",
    "description": "Lean on inference but avoid the ‘undefined’ and ‘never[]’ traps when initial state is empty.",
    "learningObjectives": [
      "Rely on inference for obvious cases",
      "Annotate state when initial value is missing",
      "Handle arrays to avoid never[]",
      "Use unions for nullable and mixed states"
    ],
    "outline": [
      {
        "section": "Numbers and strings",
        "topics": ["Inferred types from initial value", "Functional updates"],
        "examples": "Accident Counter: add count and draftCount state.",
        "flow": "Start simple → inspect inference → add updates. "
      },
      {
        "section": "Empty and array cases",
        "topics": ["Quote | undefined", "Quote[] with explicit generic"],
        "examples": "Inspirational Quotes: fix undefined and never[] issues.",
        "flow": "Demonstrate errors → introduce explicit type args. "
      }
    ]
  },
  {
    "id": "forms-events-and-number-inputs",
    "title": "Forms, Events, and Number Inputs That Don’t Lie",
    "description": "Type form handlers once, reuse everywhere—and tame <input type=\"number\"> returning strings.",
    "learningObjectives": [
      "Create reusable typed change handlers",
      "Coerce or model number inputs safely",
      "Share handler types across components"
    ],
    "outline": [
      {
        "section": "Reusable handlers",
        "topics": [
          "ChangeEventHandler<HTMLInputElement>",
          "Single handleChange for multiple inputs"
        ],
        "examples": "Quote filter: one handler updates named fields.",
        "flow": "Duplicate handlers → extract → type once. "
      },
      {
        "section": "Numbers are strings (sigh)",
        "topics": ["Coercion strategies", "Template‑literal types for stricter numeric inputs"],
        "examples": "Refactor number input using parse / Number / template literals.",
        "flow": "Show bug → fix with coercion → explore stricter typing. "
      }
    ]
  },
  {
    "id": "unions-for-ui-state",
    "title": "Model UI State with Discriminated Unions",
    "description": "Express loading/success/error cleanly—exhaustive checks stop the foot‑guns before they fire.",
    "learningObjectives": [
      "Design union types for request status",
      "Guard and narrow for safe rendering",
      "Use exhaustive switch with never"
    ],
    "outline": [
      {
        "section": "From booleans to unions",
        "topics": ["status: 'loading' | 'error' | 'success'", "Switch‑based rendering"],
        "examples": "Inspirational Quotes: render per request state.",
        "flow": "Replace flags → switch → add never exhaustiveness. "
      }
    ]
  },
  {
    "id": "typing-reducers-and-actions",
    "title": "Typing Reducers and Actions the Practical Way",
    "description": "Ditch string constants—use unions for actions, payloads, and reducers with real compile‑time help.",
    "learningObjectives": [
      "Type State and Action unions",
      "Get autocomplete for action.type",
      "Enforce payload shape per action"
    ],
    "outline": [
      {
        "section": "Action unions",
        "topics": ["type: 'increment' | 'update-draft'", "Payload typing per action"],
        "examples": "Accident Counter reducer with typed actions.",
        "flow": "Start with any → replace with discriminated union → profit. "
      },
      {
        "section": "Real apps",
        "topics": ["Color reducer with typed actions", "Dispatch typing through props"],
        "examples": "colors app: dispatch typed from Application → child.",
        "flow": "Extract ColorActions → thread through → add guardrails. "
      }
    ]
  },
  {
    "id": "passing-dispatch-and-context",
    "title": "From Passing Dispatch to Context",
    "description": "Stop prop drilling—introduce a typed Context and migrate dispatch to a Provider with safety.",
    "learningObjectives": [
      "Create a typed context value",
      "Avoid undefined via asserts or custom hooks",
      "Refactor consumers to use context"
    ],
    "outline": [
      {
        "section": "Prop drilling pain",
        "topics": ["Dispatch type discovery via hover", "Threading props through multiple layers"],
        "examples": "colors app: pass dispatch to HexToRGB and SavedColors.",
        "flow": "Show friction → motivate Context. "
      },
      {
        "section": "Typed Context",
        "topics": [
          "Asserting initial value vs generic createContext helper",
          "Provider and consumer hooks"
        ],
        "examples": "Build ColorContext; then replace prop drilling with useContext.",
        "flow": "Define type → assert/create helper → refactor consumers. "
      }
    ]
  },
  {
    "id": "safer-createcontext-helpers",
    "title": "Safer Context: Custom createContext and Hooks",
    "description": "No more maybe‑undefined context—return a typed hook and Provider tuple that never lies.",
    "learningObjectives": [
      "Write a generic createContext<T>() helper",
      "Throw early when used outside a Provider",
      "Expose read and dispatch via custom hooks"
    ],
    "outline": [
      {
        "section": "Generic helper",
        "topics": [
          "React.createContext<T | undefined>",
          "Custom useContext that throws if missing"
        ],
        "examples": "colors app: createContext returns [useCtx, Provider].",
        "flow": "Implement helper → swap into context.tsx → simplify hooks. "
      },
      {
        "section": "Selector‑style hooks",
        "topics": ["useDispatch() and useHexColor()", "Memoizing returns"],
        "examples": "Derive typed selectors from ColorContext.",
        "flow": "Add hooks → memoize outputs → replace ad‑hoc useContext calls. "
      }
    ]
  },
  {
    "id": "just-enough-generics",
    "title": "Just Enough Generics for React",
    "description": "Use generics to write reusable components and hooks—without disappearing into type wizardry.",
    "learningObjectives": [
      "Declare and infer generic parameters",
      "Constrain generics and use defaults",
      "Apply generics to components, hooks, and utilities"
    ],
    "outline": [
      {
        "section": "Warm‑up",
        "topics": ["identity<T>, Link<T>", "Generic helpers like ValueOf<T>"],
        "examples": "Implement tap<T>(value, fn) utility and infer T.",
        "flow": "Start with functions → lift into React components. "
      },
      {
        "section": "Components and hooks",
        "topics": ["List<T> component with renderItem", "useMouseMove<T extends HTMLElement>()"],
        "examples": "Generic List and a ref‑based custom hook.",
        "flow": "Introduce constraints → show inference at call sites. "
      }
    ]
  },
  {
    "id": "function-overloads-in-react",
    "title": "Function Overloads for Flexible APIs",
    "description": "Use overloads to model ergonomic APIs—curried helpers, either‑or props, and safe fallbacks.",
    "learningObjectives": [
      "Author multiple call signatures",
      "Model partial application with overloads",
      "Use overloads in component props when appropriate"
    ],
    "outline": [
      {
        "section": "Overloads 101",
        "topics": ["Multiple signatures, one implementation", "Currying add(a)(b) example"],
        "examples": "Build add with two overloads; TS infers perfectly.",
        "flow": "Write signatures → implement → test inference. "
      },
      {
        "section": "Component cases",
        "topics": ["Prop overloads with unions", "Interplay with discriminants"],
        "examples": "Text component: overload when truncate is true vs false.",
        "flow": "Show ergonomics vs complexity → choose judiciously. "
      }
    ]
  },
  {
    "id": "utility-types-in-practice",
    "title": "Utility Types That Unlock Clean React APIs",
    "description": "Partial, Pick, Omit, Record—use them to clean up state updates, prop shaping, and public surfaces.",
    "learningObjectives": [
      "Use Partial<T> for update shapes",
      "Pick/Omit to compose public component props",
      "Record and index signatures safely"
    ],
    "outline": [
      {
        "section": "Real refactors",
        "topics": ["Replace any with Partial<Item>", "Public Props via Omit"],
        "examples": "Packing List: update(id, updates: Partial<Item>).",
        "flow": "Identify any → derive Partial → propagate fixes. "
      }
    ]
  },
  {
    "id": "template-literal-types",
    "title": "Template Literal Types for Safer APIs",
    "description": "Build expressive string unions—alignment, action types, and variant maps become compile‑time safe.",
    "learningObjectives": [
      "Compose string unions with template literals",
      "Create exact action type strings",
      "Validate config objects with satisfies"
    ],
    "outline": [
      {
        "section": "Strings with structure",
        "topics": [
          "Alignment = `${Vertical}-${Horizontal}`",
          "ActionTypes = `update-${keyof Model}`"
        ],
        "examples": "Enforce 'chaotic-good' style alignments; action name unions.",
        "flow": "Show unsafe strings → add TL types → get autocomplete. "
      },
      {
        "section": "satisfies operator",
        "topics": ["Validate maps without widening"],
        "examples": "Variant → className map validated with satisfies.",
        "flow": "Define schema type → use satisfies → keep literal keys. "
      }
    ]
  },
  {
    "id": "mirror-dom-props",
    "title": "Mirroring DOM Props with ComponentPropsWithoutRef",
    "description": "Wrap native elements without losing typing—pass through every valid prop and keep autocomplete.",
    "learningObjectives": [
      "Use ComponentPropsWithoutRef<'tag'>",
      "Refactor custom inputs and buttons to mirror DOM props",
      "Intersect your custom props with intrinsic ones"
    ],
    "outline": [
      {
        "section": "Input wrapper",
        "topics": ["ComponentPropsWithoutRef<'input'>", "Label + input with pass‑through"],
        "examples": "LabeledInput mirroring all input attributes.",
        "flow": "Start manual prop list → replace with intrinsic props. "
      },
      {
        "section": "Button variants",
        "topics": ["Narrow variant/size unions", "Class merging"],
        "examples": "Button with variant and size plus full DOM props.",
        "flow": "Constrain unions → preserve DOM attributes. "
      }
    ]
  },
  {
    "id": "polymorphic-as-prop",
    "title": "Polymorphic Components and the as Prop",
    "description": "Render as 'a', 'button', or 'p'—correct props and refs follow automatically with generics.",
    "learningObjectives": [
      "Model polymorphic props with ElementType",
      "Forward refs with correct instance types",
      "Omit conflicting props cleanly"
    ],
    "outline": [
      {
        "section": "Generic polymorphism",
        "topics": ["PolymorphicProps<E, P>", "Omit conflicting keys and 'as'"],
        "examples": "Text and Box that switch underlying tags safely.",
        "flow": "Define helper types → implement → usage examples. "
      }
    ]
  },
  {
    "id": "componenttype-hocs-render-props",
    "title": "ComponentType, HOCs, and Render Props",
    "description": "Compose behavior without losing types—wrap components, infer injected props, or render via functions.",
    "learningObjectives": [
      "Use React.ComponentType<P> to accept components by contract",
      "Type HOCs that inject props and forward refs",
      "Type render props with function signatures"
    ],
    "outline": [
      {
        "section": "Component contracts",
        "topics": ["React.ComponentType<{ status: ... }>", "Runtime feedback when types mismatch"],
        "examples": "WithLoadingStatus only accepts components with a status prop.",
        "flow": "Define constraint → show compile error on mismatch. "
      },
      {
        "section": "HOC vs render props",
        "topics": ["withMouseMove<T>()", "MouseMove render prop"],
        "examples": "Type both patterns and compare ergonomics.",
        "flow": "Implement HOC → implement render prop → choose per use case. "
      }
    ]
  },
  {
    "id": "custom-hooks-with-generics",
    "title": "Designing Custom Hooks with Generics and Refs",
    "description": "Expose ergonomic, typed hooks—return tuples or objects; type refs and event listeners safely.",
    "learningObjectives": [
      "Return tuple vs object APIs",
      "Type DOM refs and event listeners",
      "Constrain generic parameters for clarity"
    ],
    "outline": [
      {
        "section": "Ref‑driven hooks",
        "topics": ["useMouseMove<T extends HTMLElement>()", "Event add/remove with cleanup"],
        "examples": "Track mouse position over a div via a typed ref.",
        "flow": "Define generic → attach listeners → return ref + state. "
      }
    ]
  },
  {
    "id": "prop-combinations-and-unions",
    "title": "Prop Combinations: Permit, Limit, and Require",
    "description": "Make illegal prop combos unrepresentable—use unions, XOR patterns, and overloads.",
    "learningObjectives": [
      "Limit mutually exclusive flags with unions",
      "Require props conditionally with discriminants",
      "Use overloads to enforce relationships"
    ],
    "outline": [
      {
        "section": "Exclusive variants",
        "topics": ["Primary | Secondary | Destructive", "never for excluded props"],
        "examples": "Button variants where only one style prop is allowed.",
        "flow": "Model base props → add exclusivity → compile‑time guard. "
      },
      {
        "section": "Required combos",
        "topics": ["truncate implies optional expanded", "Overloads for valid shapes"],
        "examples": "Text component requiring truncate before expanded.",
        "flow": "Show broken shape → fix with overloads + unions. "
      }
    ]
  },
  {
    "id": "tooling-eslint-prettier-builds",
    "title": "Tooling: ESLint, Prettier, and Build Pipelines",
    "description": "Wire type‑aware lint rules, format consistently, and split transpile vs type‑check for speedy builds.",
    "learningObjectives": [
      "Configure @typescript-eslint with type‑aware rules",
      "Avoid conflicts with Prettier formatting",
      "Run tsc --noEmit in CI while bundlers transpile"
    ],
    "outline": [
      {
        "section": "Type‑aware linting",
        "topics": ["parserOptions.project", "no-floating-promises and friends"],
        "examples": "Enable type‑aware rules only in src; keep tooling folders light.",
        "flow": "Explain perf tradeoffs → scope rules → add CI. "
      },
      {
        "section": "Transpile vs check",
        "topics": ["SWC/esbuild + tsc --noEmit", "Declaration emit for libraries"],
        "examples": "Vite app and a small component library build split.",
        "flow": "Implement split → measure improvements. "
      }
    ]
  },
  {
    "id": "module-resolution-and-paths",
    "title": "Module Resolution and Path Aliases",
    "description": "Make imports sane—align tsconfig paths with your bundler and avoid circular snags.",
    "learningObjectives": [
      "Configure baseUrl and paths",
      "Match bundler aliasing",
      "Detect and prevent cycles"
    ],
    "outline": [
      {
        "section": "Paths everywhere",
        "topics": ["moduleResolution: bundler", "Vite/Next alias sync"],
        "examples": "Add @/ to tsconfig and bundler; confirm editors resolve.",
        "flow": "Set tsconfig → configure bundler → smoke test. "
      }
    ]
  },
  {
    "id": "data-fetching-validation",
    "title": "Data Fetching with Runtime Validation",
    "description": "Types end at the network boundary—parse unknown data with Zod and expose safe types to React.",
    "learningObjectives": [
      "Treat fetched data as unknown",
      "Parse and narrow with a schema",
      "Type helpers around fetch and errors"
    ],
    "outline": [
      {
        "section": "Unknown until parsed",
        "topics": ["z.object() schemas", "z.infer for static types"],
        "examples": "Build getJSON<T>() that validates and returns typed data.",
        "flow": "Fetch → parse → render → handle failure paths. "
      }
    ]
  },
  {
    "id": "react-query-trpc",
    "title": "Typed Data Layer: React Query and tRPC",
    "description": "End‑to‑end types—from server router to client calls—plus cached queries with proper key typing.",
    "learningObjectives": [
      "Type UseQueryResult<TData, TError>",
      "Create typed query keys",
      "Leverage tRPC for inferred client types"
    ],
    "outline": [
      {
        "section": "Query keys and results",
        "topics": ["Factory functions returning as const", "Error and data typing"],
        "examples": "todoKeys factories + useQuery for list and detail views.",
        "flow": "Define keys → wire queries → enable autosuggest. "
      }
    ]
  },
  {
    "id": "rsc-server-actions",
    "title": "React Server Components and Server Actions",
    "description": "Respect the server/client boundary—serialize safely, type async components, and model actions.",
    "learningObjectives": [
      "Mark server vs client modules",
      "Type async server components and props",
      "Define server actions with validated inputs"
    ],
    "outline": [
      {
        "section": "Boundaries and types",
        "topics": ["'use server' vs 'use client'", "Serializable prop shapes"],
        "examples": "Async server component returns JSX from typed data.",
        "flow": "Create server function → call from client → ensure types flow. "
      }
    ]
  },
  {
    "id": "security-sanitization",
    "title": "Security: Escaping and Sanitized HTML Types",
    "description": "Quarantine HTML—brand sanitized strings, type helpers, and gate dangerouslySetInnerHTML behind safety.",
    "learningObjectives": [
      "Avoid passing raw HTML",
      "Create branded SafeHtml types",
      "Constrain components to safe input"
    ],
    "outline": [
      {
        "section": "Brands and factories",
        "topics": ["TrustedHTML or branded string", "sanitize() returning SafeHtml"],
        "examples": "Html component only accepts SafeHtml; compile‑time enforcement.",
        "flow": "Define brand → wrap sanitizer → consume safely. "
      }
    ]
  },
  {
    "id": "styling-and-assets",
    "title": "Styling Types and Asset Declarations",
    "description": "Type CSS Modules, inline styles, and SVG imports—stop the any‑leaks in your styling layer.",
    "learningObjectives": [
      "Use React.CSSProperties correctly",
      "Generate .d.ts for CSS Modules and assets",
      "Type SVG ReactComponent imports"
    ],
    "outline": [
      {
        "section": "Inline and modules",
        "topics": ["CSSProperties nuances", "global.d.ts for '*.module.css'"],
        "examples": "Typed class maps and safe style objects.",
        "flow": "Define declarations → import assets → verify DX. "
      }
    ]
  },
  {
    "id": "testing-typescript-react",
    "title": "Testing React Components with TypeScript",
    "description": "Set up Vitest/Jest + RTL—type queries and user events; add tsd tests to lock public APIs.",
    "learningObjectives": [
      "Configure TS‑aware test runner",
      "Type RTL queries and events",
      "Write type tests for libraries"
    ],
    "outline": [
      {
        "section": "Runner setup",
        "topics": ["Vitest + tsconfig paths", "dom lib in tests"],
        "examples": "Test Button props with type‑safe queries.",
        "flow": "Install → configure → write first tests. "
      }
    ]
  },
  {
    "id": "publishing-and-monorepos",
    "title": "Publishing Types and Monorepos",
    "description": "Emit declarations, design stable public APIs, and speed checks with project references in monorepos.",
    "learningObjectives": [
      "Emit .d.ts and map files",
      "Design stable public type surfaces",
      "Use project references and tsc -b"
    ],
    "outline": [
      {
        "section": "Library outputs",
        "topics": ["declaration and declarationMap", "package.json exports with types"],
        "examples": "UI library exporting ButtonProps; consumers get good IntelliSense.",
        "flow": "Configure tsconfig.build → verify emitted types → publish dry‑run. "
      },
      {
        "section": "Monorepo speed",
        "topics": ["composite projects", "tsc -b caching"],
        "examples": "apps/* depend on packages/ui with blazing incremental checks.",
        "flow": "Add references → run build → observe incremental behavior. "
      }
    ]
  },
  {
    "id": "performance-with-types",
    "title": "Performance Patterns Informed by Types",
    "description": "Use types to encode identity contracts—memo boundaries, readonly data, and safe deferrals.",
    "learningObjectives": [
      "Constrain props to stable identities",
      "Document areEqual contracts",
      "Use useDeferredValue and transitions with clear types"
    ],
    "outline": [
      {
        "section": "Identity and memo",
        "topics": ["Readonly arrays/maps", "Custom equality functions"],
        "examples": "DataGrid row memo keyed by RowId and version.",
        "flow": "Identify churn → encode invariants in types → profile. "
      }
    ]
  },
  {
    "id": "edge-ssr-hydration",
    "title": "Edge, SSR, and Hydration Payload Types",
    "description": "Target multiple runtimes—DOM vs Node types, serializable payloads, and safe hydration contracts.",
    "learningObjectives": [
      "Split server and client tsconfigs",
      "Constrain hydration data to serializable types",
      "Share DTOs across bundles"
    ],
    "outline": [
      {
        "section": "Two worlds, two configs",
        "topics": ["lib: DOM vs Node", "Serializable DTOs for hydration"],
        "examples": "window.**DATA** typed and validated before use.",
        "flow": "Create server/client configs → define DTO → parse on load. "
      }
    ]
  }
]
