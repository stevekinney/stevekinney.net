[
  {
    "id": "typescript-react-19-foundations",
    "title": "TypeScript + React 19 Foundations",
    "description": "Set up React 19 with TypeScript from scratch—tsconfig, JSX runtime, strict mode, linting, and project structure that scales.",
    "learningObjectives": [
      "Initialize a React 19 + TypeScript project with Vite or Next.js",
      "Configure tsconfig for JSX, module, and lib options",
      "Enable strictness flags suited for React apps",
      "Integrate ESLint + TypeScript rules that catch real bugs"
    ],
    "outline": [
      {
        "section": "Project bootstrap",
        "topics": ["Vite + TS template", "Next.js App Router + TS", "Node and browser libs"],
        "examples": "Create a new app with Vite and confirm type checking in the editor and CI.",
        "flow": "Scaffold → configure tsconfig → verify types in a basic component"
      },
      {
        "section": "JSX runtime and module settings",
        "topics": ["jsx: react-jsx", "moduleResolution", "target and lib"],
        "examples": "Switch jsx from classic to react-jsx and explain emitted JSX types.",
        "flow": "Explain options → show differences → pick sane defaults"
      }
    ]
  },
  {
    "id": "strictness-options-for-react",
    "title": "Strictness Options That Pay Off for React",
    "description": "Turn on strict TypeScript options—catch subtle runtime bugs early without drowning in red squiggles.",
    "learningObjectives": [
      "Understand strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes",
      "Apply noImplicitOverride, noFallthroughCasesInSwitch",
      "Use skipLibCheck safely in app vs library contexts",
      "Balance DX with correctness using incremental adoption"
    ],
    "outline": [
      {
        "section": "Must-have flags",
        "topics": [
          "strict and its subflags",
          "noUncheckedIndexedAccess",
          "exactOptionalPropertyTypes"
        ],
        "examples": "Refactor optional props handling with exactOptionalPropertyTypes on.",
        "flow": "Turn flags on → interpret new errors → fix patterns"
      },
      {
        "section": "Pragmatic tradeoffs",
        "topics": ["skipLibCheck", "isolatedModules", "verbatimModuleSyntax"],
        "examples": "When to keep skipLibCheck in apps but not libraries.",
        "flow": "Pros/cons → decision checklist → CI guardrails"
      }
    ]
  },
  {
    "id": "jsx-types-reactnode-reactelement",
    "title": "JSX Types: ReactNode, ReactElement, JSX.Element",
    "description": "Know the difference between ReactNode, ReactElement, and JSX.Element—type children and returns correctly every time.",
    "learningObjectives": [
      "Differentiate ReactNode vs ReactElement vs JSX.Element",
      "Type component return values and children accurately",
      "Use PropsWithChildren sparingly and alternatives",
      "Constrain render props to valid nodes"
    ],
    "outline": [
      {
        "section": "Mental model",
        "topics": [
          "What ReactNode includes",
          "When JSX.Element is too specific",
          "Element vs component type"
        ],
        "examples": "Component returning null vs fragment vs array of elements.",
        "flow": "Define terms → show pitfalls → give rules of thumb"
      },
      {
        "section": "Children typing",
        "topics": ["Explicit children prop", "ReactElement constraints", "Render props signatures"],
        "examples": "Require a single child of a specific type with ReactElement<typeof Button>.",
        "flow": "Show anti-patterns → refactor to robust types → tests"
      }
    ]
  },
  {
    "id": "typing-props-and-defaults",
    "title": "Typing Props, Defaults, and Requiredness",
    "description": "Design ergonomic props—optional vs required, defaults, unions, and doc-ready types that guide usage.",
    "learningObjectives": [
      "Define Props interfaces and type aliases",
      "Use required vs optional properties clearly",
      "Apply default values without defaultProps",
      "Expose clean public types from component modules"
    ],
    "outline": [
      {
        "section": "Props design",
        "topics": [
          "Interfaces vs type aliases",
          "Optional props and defaults",
          "Readonly props where appropriate"
        ],
        "examples": "Card component with optional actions and default heading size.",
        "flow": "Define type → implement component → auto-complete showcases"
      },
      {
        "section": "Publishing types",
        "topics": [
          "export type Props",
          "Avoiding leak of internal details",
          "JSDoc for IntelliSense"
        ],
        "examples": "Public ButtonProps with internal implementation details hidden.",
        "flow": "Separate internal vs public → re-export clean types"
      }
    ]
  },
  {
    "id": "typing-dom-and-react-events",
    "title": "Typing DOM and React Events",
    "description": "Nail event handler types—forms, inputs, mouse, keyboard, composition, and synthetic events in React.",
    "learningObjectives": [
      "Use correct React.*Event types for inputs and forms",
      "Infer target types for generic handlers",
      "Handle controlled vs uncontrolled inputs safely",
      "Type stopPropagation and preventDefault helpers"
    ],
    "outline": [
      {
        "section": "Common events",
        "topics": [
          "ChangeEvent<HTMLInputElement>",
          "MouseEvent<HTMLButtonElement>",
          "KeyboardEvent<HTMLDivElement>"
        ],
        "examples": "Build a typed form with input, select, and textarea handlers.",
        "flow": "Introduce types → handlers → extract reusable utilities"
      },
      {
        "section": "Generic handlers",
        "topics": [
          "Reusable onChange signatures",
          "Event.currentTarget vs target",
          "FormEvent and submit"
        ],
        "examples": "Create a form factory that types inputs by element tag.",
        "flow": "Design generic → demonstrate inference → tests"
      }
    ]
  },
  {
    "id": "usestate-usereducer-typing",
    "title": "Typing useState and useReducer Like a Pro",
    "description": "Model component state with precision—unions, discriminants, and reducers that prevent impossible states.",
    "learningObjectives": [
      "Type useState with unions and lazy initializers",
      "Design discriminated unions for reducers",
      "Ensure exhaustive handling with never checks",
      "Avoid nullable traps via explicit states"
    ],
    "outline": [
      {
        "section": "State modeling",
        "topics": [
          "Union states: 'idle' | 'loading' | 'error'",
          "Functional updates and inference",
          "Lazy initialization"
        ],
        "examples": "Async widget with Idle/Loading/Success/Error union state.",
        "flow": "Define union → implement transitions → enforce exhaustiveness"
      },
      {
        "section": "Reducers",
        "topics": [
          "Action unions with payloads",
          "Reducer return types",
          "useReducer with init and initializer"
        ],
        "examples": "Cart reducer with precise item updates and never-allowed actions.",
        "flow": "Design actions → reducer → typed dispatch"
      }
    ]
  },
  {
    "id": "useref-and-imperative-handles",
    "title": "useRef, Callback Refs, and Imperative Handles",
    "description": "Type refs to DOM nodes and components—safely expose imperative APIs with forwardRef and useImperativeHandle.",
    "learningObjectives": [
      "Use RefObject for DOM elements",
      "Type callback refs for interop",
      "Expose typed imperative handles",
      "Handle nullability without non-null assertions"
    ],
    "outline": [
      {
        "section": "DOM refs",
        "topics": ["useRef<HTMLInputElement | null>", "Nullable patterns", "Ref callbacks"],
        "examples": "Focus an input after mount with typed ref.",
        "flow": "Create ref → optional chaining → safe usage helpers"
      },
      {
        "section": "Imperative APIs",
        "topics": ["forwardRef with generics", "useImperativeHandle", "ForwardedRef vs RefObject"],
        "examples": "Modal exposing open/close methods with a typed handle.",
        "flow": "Define handle interface → forwardRef → consumer usage"
      }
    ]
  },
  {
    "id": "context-and-selectors-typing",
    "title": "Typing Context and Selector Patterns",
    "description": "Create fully typed contexts—state/actions split, selectors that minimize re-renders, and ergonomic Provider APIs.",
    "learningObjectives": [
      "Declare context types without default value footguns",
      "Split read and write contexts for stability",
      "Add typed selectors for granular subscriptions",
      "Model Provider props and value factories"
    ],
    "outline": [
      {
        "section": "Safe context creation",
        "topics": ["createContext<T | undefined>", "useContext guard hooks", "Provider typing"],
        "examples": "UserContext with a typed useUser() hook that throws if missing.",
        "flow": "Define types → implement provider → consumer guard"
      },
      {
        "section": "Selectors",
        "topics": [
          "Context selector pattern",
          "Memoized derived values",
          "Stable actions identities"
        ],
        "examples": "Todo app with StateContext and ActionsContext to reduce re-renders.",
        "flow": "Split contexts → add selectors → profile"
      }
    ]
  },
  {
    "id": "custom-hooks-and-generics",
    "title": "Designing Custom Hooks with Generics and Inference",
    "description": "Author hooks that feel built-in—clean generics, overloads, and return types that infer naturally from inputs.",
    "learningObjectives": [
      "Write generic hooks with constrained type params",
      "Use overloads for ergonomic return types",
      "Model async hook states with unions",
      "Publish hook types with minimal public surface"
    ],
    "outline": [
      {
        "section": "Generic inputs and returns",
        "topics": ["Constrained generics", "Overloads vs conditional types", "Tuple return typing"],
        "examples": "useList<T> with typed mutations and selectors.",
        "flow": "Design API → implement → verify inference"
      },
      {
        "section": "Async hooks",
        "topics": ["Promise types and Awaited<T>", "Error modeling", "Cancelable flows"],
        "examples": "useFetch<T> with AbortController and Suspense compatibility.",
        "flow": "Define states → implement → tests"
      }
    ]
  },
  {
    "id": "polymorphic-components-and-as-prop",
    "title": "Polymorphic Components and the as Prop",
    "description": "Build components that render different tags while preserving proper props—no any, no lies, just safe polymorphism.",
    "learningObjectives": [
      "Model polymorphic components using generics",
      "Preserve intrinsic element props based on as",
      "Merge custom props with HTML attributes safely",
      "Prevent invalid combinations at compile time"
    ],
    "outline": [
      {
        "section": "Typing the as prop",
        "topics": [
          "ElementType and ComponentPropsWithRef",
          "Omitting conflicting props",
          "Forwarding refs across variants"
        ],
        "examples": "Button that can render as a or Link with correct href/target props.",
        "flow": "Define base props → generic ElementType → conflict resolution"
      },
      {
        "section": "Ergonomics",
        "topics": [
          "Default element parameter",
          "IntelliSense for variants",
          "Satisfies operator for prop maps"
        ],
        "examples": "Variant map object validated with satisfies to avoid typos.",
        "flow": "Refactor → DX check → tests"
      }
    ]
  },
  {
    "id": "forwardref-memo-and-displayname",
    "title": "forwardRef, memo, and displayName with TypeScript",
    "description": "Compose forwardRef and memo without losing types—fix common inference pitfalls and keep good devtools labels.",
    "learningObjectives": [
      "Type forwardRef components with generics",
      "Wrap with memo while preserving props",
      "Set displayName safely for better debugging",
      "Write areEqual with typed props"
    ],
    "outline": [
      {
        "section": "Correct signatures",
        "topics": [
          "ForwardRefExoticComponent",
          "PropsWithoutRef and RefAttributes",
          "Generic props preservation"
        ],
        "examples": "DataList<T> with forwardRef to ul and memo wrapping.",
        "flow": "Start simple → add ref → wrap in memo → verify props inference"
      },
      {
        "section": "Equality functions",
        "topics": ["areEqual typing", "Readonly props and structural sharing"],
        "examples": "Custom row equality that compares id and version fields.",
        "flow": "Implement → micro-benchmark → guardrails"
      }
    ]
  },
  {
    "id": "higher-order-components-typing",
    "title": "Typing Higher-Order Components Without Tears",
    "description": "Wrap components and keep their props—model HOCs with generics, Omit, and proper ref forwarding.",
    "learningObjectives": [
      "Infer wrapped component props with ComponentType",
      "Omit injected props from the outer surface",
      "Preserve generics on the inner component",
      "Handle refs via forwardRef in HOCs"
    ],
    "outline": [
      {
        "section": "Prop surgery",
        "topics": [
          "JSX.LibraryManagedAttributes",
          "Omit and intersection types",
          "Inferring defaulted props"
        ],
        "examples": "withTheme HOC that injects theme while preserving user props.",
        "flow": "Define injected props → type the wrapper → validate"
      },
      {
        "section": "Refs and generics",
        "topics": [
          "hoist-non-react-statics types",
          "ForwardedRef in HOCs",
          "Generic inner components"
        ],
        "examples": "withTracking<T> that preserves generic row type.",
        "flow": "Baseline HOC → add ref support → generic support"
      }
    ]
  },
  {
    "id": "forms-actions-and-useactionstate",
    "title": "Typed Forms, Actions, and useActionState",
    "description": "Model form mutations in React 19—type Actions and useActionState for safe server and client flows.",
    "learningObjectives": [
      "Define Action function types and return shapes",
      "Use useActionState with typed pending/result",
      "Validate inputs with schema libraries and infer types",
      "Propagate error and field messages safely"
    ],
    "outline": [
      {
        "section": "Action signatures",
        "topics": ["Input and output typing", "Error channels", "Optimistic updates"],
        "examples": "Login form Action that returns union of success or field errors.",
        "flow": "Define types → implement action → wire useActionState"
      },
      {
        "section": "Schema inference",
        "topics": [
          "zod/yup type inference",
          "narrowing on result tags",
          "FormData parsing helpers"
        ],
        "examples": "Infer server validation types and surface them to the client.",
        "flow": "Write schema → infer → serialize across boundary"
      }
    ]
  },
  {
    "id": "the-use-hook-and-suspense-typing",
    "title": "Typing the use() Hook and Suspense Data",
    "description": "Consume promises and resources directly—type use() calls, Suspense fallbacks, and async component returns.",
    "learningObjectives": [
      "Use the use() hook with Promise and resource types",
      "Type async server components correctly",
      "Model loading/error states with Suspense and boundaries",
      "Share resource types across client and server"
    ],
    "outline": [
      {
        "section": "use() basics",
        "topics": ["Awaited<T>", "Typing resources", "Error boundaries"],
        "examples": "Profile component loading a user with use() and Suspense fallback.",
        "flow": "Define resource type → call use() → error boundary wiring"
      },
      {
        "section": "Server vs client",
        "topics": [
          "Async server components return types",
          "Client wrappers around server data",
          "Cache identity typing"
        ],
        "examples": "Server list component returning JSX with typed items.",
        "flow": "Server type → client props → shared types package"
      }
    ]
  },
  {
    "id": "data-fetching-and-runtime-validation",
    "title": "Data Fetching and Runtime Validation",
    "description": "Fetch safely—type APIs, validate at runtime, and keep server/client boundaries honest under React 19.",
    "learningObjectives": [
      "Define API response types and validate with schemas",
      "Handle unknown safely with narrowing",
      "Create typed fetch wrappers and errors",
      "Model paginated and cursor-based results"
    ],
    "outline": [
      {
        "section": "Typed fetch",
        "topics": ["Response decoding", "Narrowing unknown", "Retryable errors"],
        "examples": "getJSON<T>() helper that validates and throws typed errors.",
        "flow": "Write helper → consume in components → test failures"
      },
      {
        "section": "Pagination",
        "topics": ["Cursor types", "Infinite lists and Suspense", "Stable cache keys"],
        "examples": "Feed component with typed Page<T> and cursor params.",
        "flow": "Design types → implement → measure"
      }
    ]
  },
  {
    "id": "error-boundaries-and-suspense-boundaries",
    "title": "Error Boundaries and Suspense Boundaries",
    "description": "Type error and suspense boundaries—ensure fallback components and error info props are accurately modeled.",
    "learningObjectives": [
      "Implement ErrorBoundary with componentDidCatch types",
      "Type Suspense fallbacks and lazy components",
      "Model recoverable vs terminal errors",
      "Test error flows with TS-aware utilities"
    ],
    "outline": [
      {
        "section": "Error boundary types",
        "topics": ["Error and info types", "Fallback render props"],
        "examples": "Route-level ErrorBoundary with typed reset handler.",
        "flow": "Define props → implement → simulate errors"
      },
      {
        "section": "Lazy and Suspense",
        "topics": ["React.lazy typing", "Fallback props patterns"],
        "examples": "Split heavy chart and type lazy import default.",
        "flow": "Create lazy module → ensure correct type import → wire Suspense"
      }
    ]
  },
  {
    "id": "react-server-components-types",
    "title": "React Server Components: Type-Safe Boundaries",
    "description": "Type server-only and client-only components—share contracts, serialize safely, and enforce correct usage.",
    "learningObjectives": [
      "Mark server vs client modules and surface types",
      "Pass serializable props across the boundary",
      "Share DTO and domain types safely",
      "Use cache() with typed keys and values"
    ],
    "outline": [
      {
        "section": "Boundary contracts",
        "topics": [
          "Serializable prop shapes",
          "Client component wrappers",
          "Server-only utilities"
        ],
        "examples": "ProductDetails.server with typed data; ProductActions.client with typed handlers.",
        "flow": "Define DTO → build server comp → wrap for client"
      },
      {
        "section": "Caching",
        "topics": ["cache() identity", "Invalidation typing", "Key derivation"],
        "examples": "Cache catalog lookups keyed by locale and user role.",
        "flow": "Design key type → implement cache → measure hits"
      }
    ]
  },
  {
    "id": "resource-preloading-apis-types",
    "title": "Resource Preloading APIs with TypeScript",
    "description": "Preload, preinit, and prefetch with confidence—type helpers to avoid duplicate loads and mismatched priorities.",
    "learningObjectives": [
      "Wrap preload/prefetch APIs with safe types",
      "Model priorities and as attributes",
      "Emit link headers from server with typed helpers",
      "Test that assets are hinted only once"
    ],
    "outline": [
      {
        "section": "Typed helpers",
        "topics": [
          "as: 'script' | 'style' | 'font'",
          "Module preinit signatures",
          "De-duplication maps"
        ],
        "examples": "preloadFont(name, weight) that returns idempotent handles.",
        "flow": "Define helper types → implement → verify network"
      },
      {
        "section": "Server integration",
        "topics": ["Link headers", "HTML injection", "SSR considerations"],
        "examples": "Emit typed link headers for route modules.",
        "flow": "Server util → route hook → test headers"
      }
    ]
  },
  {
    "id": "concurrent-features-typing",
    "title": "Typing Concurrent Features: Transitions and Deferrals",
    "description": "Type useTransition, startTransition, and useDeferredValue—model pending UI and deferred derived data.",
    "learningObjectives": [
      "Use useTransition return types correctly",
      "Type pending indicators and UI states",
      "Defer expensive derived values with accurate types",
      "Design APIs that accept transitions as dependencies"
    ],
    "outline": [
      {
        "section": "Transitions",
        "topics": ["Return tuple typing", "Pending state modeling", "startTransition typing"],
        "examples": "Search UI with typed pending boolean and spinner variants.",
        "flow": "Implement → wrap updates → test responsiveness"
      },
      {
        "section": "Deferred values",
        "topics": ["useDeferredValue<T>", "Derived selectors and memo"],
        "examples": "Defer filtered array type T[] without losing inference.",
        "flow": "Baseline heavy compute → add deferral → verify types"
      }
    ]
  },
  {
    "id": "useoptimistic-typed-optimism",
    "title": "useOptimistic and Typed Optimistic Updates",
    "description": "Model optimistic UI updates safely—design optimistic state and reconcile server results with precise types.",
    "learningObjectives": [
      "Define optimistic state shapes",
      "Type optimistic actions vs server confirmations",
      "Handle rollback paths explicitly",
      "Avoid double-apply bugs via tags/versions"
    ],
    "outline": [
      {
        "section": "Optimistic modeling",
        "topics": ["Local temp IDs", "Version stamps", "Conflict resolution"],
        "examples": "Add-to-cart optimistic row with temp id merged into server id.",
        "flow": "Design state → apply optimistic → reconcile server"
      },
      {
        "section": "Ergonomics",
        "topics": ["Helper utilities", "Narrowing via discriminants"],
        "examples": "Result union { kind: 'ok' | 'conflict' | 'error' } drives UI branches.",
        "flow": "Define union → exhaustive switch → tests"
      }
    ]
  },
  {
    "id": "measuring-performance-typesafe",
    "title": "Type-Safe Performance Patterns",
    "description": "Use types to prevent accidental churn—stable identities, typed selectors, and memo boundaries that actually help.",
    "learningObjectives": [
      "Constrain prop shapes to stable identities",
      "Type custom areEqual for memoized components",
      "Use readonly arrays/maps to signal immutability",
      "Document performance contracts in types"
    ],
    "outline": [
      {
        "section": "Identity stability",
        "topics": ["Readonly and const assertions", "useMemo for referential equality"],
        "examples": "Toolbar passing stable action IDs instead of new objects.",
        "flow": "Identify churn → add types → confirm with Profiler"
      },
      {
        "section": "Memo contracts",
        "topics": ["areEqual prop typing", "Selector input typing"],
        "examples": "DataGrid row memo equality typed against RowKey and Version.",
        "flow": "Declare contract → implement → measure"
      }
    ]
  },
  {
    "id": "code-splitting-lazy-types",
    "title": "Code-Splitting and Lazy Types",
    "description": "Split components with React.lazy and keep types intact—ensure default exports, props, and suspense fallbacks match.",
    "learningObjectives": [
      "Type React.lazy imports and props",
      "Create typed loaders for route-based splits",
      "Surface error types for lazy failures",
      "Document chunk boundaries via types"
    ],
    "outline": [
      {
        "section": "Lazy mechanics",
        "topics": ["Default export requirement", "Props inference", "Fallback typing"],
        "examples": "Lazy Chart component with typed props and fallback skeleton.",
        "flow": "Implement lazy → wire Suspense → handle errors"
      },
      {
        "section": "Routing",
        "topics": ["Split by route", "Typed loader data", "Preloading on hover"],
        "examples": "Preload next route module with typed helper.",
        "flow": "Define helper → integrate → verify types"
      }
    ]
  },
  {
    "id": "styling-csstype-and-css-modules",
    "title": "Styling Types: csstype, CSS Modules, and Inline Styles",
    "description": "Type your styles—inline style objects, CSS Modules declarations, and styled-system props without any escapes.",
    "learningObjectives": [
      "Use CSSProperties for inline styles safely",
      "Generate .d.ts for CSS Modules and assets",
      "Model variant maps with satisfies",
      "Avoid leaky any in style utilities"
    ],
    "outline": [
      {
        "section": "Inline styles",
        "topics": ["React.CSSProperties", "Vendor prefixes", "Numeric vs string values"],
        "examples": "Animated style helper returning typed properties.",
        "flow": "Define helpers → infer keys → examples in components"
      },
      {
        "section": "Modules and assets",
        "topics": ["Declaration files", "Typed className maps", "Asset module declarations"],
        "examples": "global.d.ts for '*.module.css' and '*.svg' with ReactComponent.",
        "flow": "Add d.ts → import styles → IntelliSense win"
      }
    ]
  },
  {
    "id": "accessibility-and-aria-typing",
    "title": "Accessibility Types and ARIA Props",
    "description": "Bake a11y into types—ensure valid ARIA usage and constrain props so inaccessible states can’t compile.",
    "learningObjectives": [
      "Use aria-* prop types on intrinsic elements",
      "Model required relationships (aria-controls/owns)",
      "Constrain interactive role props",
      "Build typed a11y utilities"
    ],
    "outline": [
      {
        "section": "Intrinsic a11y",
        "topics": ["ARIA attributes on JSX.IntrinsicElements", "Role-specific constraints"],
        "examples": "MenuButton that enforces aria-expanded and id patterns.",
        "flow": "Identify constraints → encode in types → examples"
      },
      {
        "section": "Utilities",
        "topics": ["Id generation", "DescribedBy linking", "Focus management typing"],
        "examples": "createAriaIds helper returning strongly typed ids.",
        "flow": "Define helper → consume → tests"
      }
    ]
  },
  {
    "id": "testing-react-typescript",
    "title": "Testing React Components with TypeScript",
    "description": "Configure Jest/Vitest and RTL for TypeScript—type-safe queries, user events, and mock helpers.",
    "learningObjectives": [
      "Set up TS-aware test runners",
      "Type user-event and query helpers",
      "Mock modules with correct types",
      "Write tsd tests for public component APIs"
    ],
    "outline": [
      {
        "section": "Runners and config",
        "topics": ["ts-jest or SWC", "Vitest + tsconfig paths", "dom lib in tests"],
        "examples": "Vitest config that respects TS path aliases.",
        "flow": "Install → configure → smoke test"
      },
      {
        "section": "API testing",
        "topics": ["Type-level tests with tsd", "Public Props contracts", "Regression guards"],
        "examples": "tsd test that Button as='a' requires href.",
        "flow": "Author failing test → fix types → lock in"
      }
    ]
  },
  {
    "id": "state-libraries-and-context-interop",
    "title": "Interop with State Libraries and Context",
    "description": "Type Redux Toolkit, Zustand, and context selectors—strongly typed stores that feel native in React.",
    "learningObjectives": [
      "Type store slices and selectors",
      "Infer actions and thunks",
      "Compose store types with React context",
      "Avoid any via helper utilities"
    ],
    "outline": [
      {
        "section": "Stores and selectors",
        "topics": ["Selector result typing", "Typed hooks useAppSelector/useStore"],
        "examples": "Create a typed selector that memoizes derived totals.",
        "flow": "Define slice types → write selectors → consume in components"
      },
      {
        "section": "Context interop",
        "topics": ["Providing typed store in context", "Selector context hooks"],
        "examples": "Zustand store provided via context with useStore(selector).",
        "flow": "Wrap provider → typed hooks → examples"
      }
    ]
  },
  {
    "id": "routing-and-params-typing",
    "title": "Routing and Typed URL Params",
    "description": "Make routes typesafe—constrain path params, search params, and loaders so links and pages never disagree.",
    "learningObjectives": [
      "Model route params and query strings",
      "Create typed link builders",
      "Parse and validate search params",
      "Share param types between client and server"
    ],
    "outline": [
      {
        "section": "Params and queries",
        "topics": [
          "Record<string, string> pitfalls",
          "Branded types for IDs",
          "Search param helpers"
        ],
        "examples": "products/:id route with branded ProductId and typed URL builder.",
        "flow": "Define brands → build helpers → use in components"
      },
      {
        "section": "Validation",
        "topics": ["Schema to type inference", "Fallback/default values"],
        "examples": "zod schema for filters → type-safe parsing in page component.",
        "flow": "Write schema → parse → supply typed props"
      }
    ]
  },
  {
    "id": "monorepos-and-shared-ui-types",
    "title": "Monorepos: Sharing UI Libraries and Types",
    "description": "Set up a typed shared UI package—project references, path aliases, and d.ts emission without tears.",
    "learningObjectives": [
      "Configure project references for multi-package builds",
      "Emit declarations for component libraries",
      "Share ESLint and tsconfig bases",
      "Test public types across packages"
    ],
    "outline": [
      {
        "section": "Project references",
        "topics": ["composite and declaration", "build order", "tsc -b workflows"],
        "examples": "ui and app packages with incremental builds.",
        "flow": "Create base config → add references → CI build"
      },
      {
        "section": "Types as contracts",
        "topics": ["Exported Props and utility types", "Avoid internal type leaks"],
        "examples": "ui/Button exports ButtonProps; internal variants remain private.",
        "flow": "Public API design → d.ts check → tsd tests"
      }
    ]
  },
  {
    "id": "assets-and-module-declarations",
    "title": "Assets and Module Declarations",
    "description": "Teach TypeScript about CSS, images, and SVGs—write module declarations that make imports type-safe.",
    "learningObjectives": [
      "Create global.d.ts for asset types",
      "Use ReactComponent for SVGs",
      "Handle JSON imports with typings",
      "Prevent untyped any asset imports"
    ],
    "outline": [
      {
        "section": "Declaring modules",
        "topics": ["CSS/SCSS module typing", "SVG component typing", "Image file types"],
        "examples": "Import styles from file.module.css and get typed class names.",
        "flow": "Write declarations → import in components → DX check"
      },
      {
        "section": "JSON and config",
        "topics": ["resolveJsonModule", "Readonly config shapes"],
        "examples": "Static config.json consumed with readonly type.",
        "flow": "Enable option → import → enforce immutability"
      }
    ]
  },
  {
    "id": "eslint-prettier-and-type-aware-rules",
    "title": "ESLint, Prettier, and Type-Aware Rules",
    "description": "Wire ESLint with type-aware rules—catch bugs like unsafe spreads, any leaks, and unhandled promises.",
    "learningObjectives": [
      "Configure @typescript-eslint with project service",
      "Enable type-aware rules only where needed",
      "Avoid conflicts with Prettier",
      "Add CI checks for types and lint"
    ],
    "outline": [
      {
        "section": "Config",
        "topics": ["parserOptions.project", "rules that need type info", "Performance tips"],
        "examples": "Enable no-floating-promises in src but not in tooling.",
        "flow": "Set up config → scope rules → run on CI"
      },
      {
        "section": "Prettier interop",
        "topics": ["Disable stylistic ESLint rules", "Prettier plugin and ignore files"],
        "examples": "Consistent formatting for .tsx and .mdx files.",
        "flow": "Install → configure → sanity check"
      }
    ]
  },
  {
    "id": "build-pipeline-tsc-swc",
    "title": "Build Pipeline: tsc, SWC, and Vite",
    "description": "Choose the right compiler and checker—separate type checking from transpile for fast builds and reliable CI.",
    "learningObjectives": [
      "Differentiate type checking vs transpiling",
      "Use SWC or esbuild with tsc --noEmit",
      "Speed up dev with incremental and project refs",
      "Catch errors in CI without slowing developers"
    ],
    "outline": [
      {
        "section": "Transpile vs types",
        "topics": ["tsc noEmit", "SWC/esbuild speed", "Source maps and JSX"],
        "examples": "Vite dev server + separate tsc checker in parallel.",
        "flow": "Split steps → measure speed → ensure correctness"
      },
      {
        "section": "CI strategy",
        "topics": ["Type check all packages", "Cache node_modules and tsbuildinfo"],
        "examples": "GitHub Actions matrix running tsc -b on monorepo.",
        "flow": "Implement workflow → cache → drop build time"
      }
    ]
  },
  {
    "id": "module-resolution-and-path-aliases",
    "title": "Module Resolution and Path Aliases",
    "description": "Use modern module resolution—align tsconfig paths with bundlers and avoid broken imports in editors vs builds.",
    "learningObjectives": [
      "Pick moduleResolution appropriate for bundlers",
      "Define and use path aliases safely",
      "Sync TS paths with Vite/Next config",
      "Prevent circular import snafus via types"
    ],
    "outline": [
      {
        "section": "Resolution basics",
        "topics": ["bundler vs node", "baseUrl and paths", "Exports field awareness"],
        "examples": "@ui/* alias consumed by both app and Storybook.",
        "flow": "Add paths → configure bundler plugin → verify"
      },
      {
        "section": "Health checks",
        "topics": ["noCircularDeps lint", "barrel file pitfalls"],
        "examples": "Detect cycles via types-only imports and split barrels.",
        "flow": "Analyze graph → refactor → enforce"
      }
    ]
  },
  {
    "id": "migrating-javascript-to-typescript",
    "title": "Migrating a React App from JS to TS",
    "description": "Convert safely—incremental tsconfig, strictness ratchet, and patterns for typing legacy components without churn.",
    "learningObjectives": [
      "Adopt TypeScript file by file",
      "Add ambient declarations to unblock",
      "Refactor any-heavy areas to safe types",
      "Track progress with strictness budgets"
    ],
    "outline": [
      {
        "section": "Incremental plan",
        "topics": ["allowJs and checkJs", "JSDoc types", "Renaming to .tsx"],
        "examples": "Introduce types to a legacy form module via JSDoc first.",
        "flow": "Enable allowJs → add JSDoc → convert to TSX"
      },
      {
        "section": "Risk management",
        "topics": ["Ambient any stubs", "Progressive strict flags"],
        "examples": "Stub external lib types to keep moving, then replace.",
        "flow": "Add stubs → replace iteratively → tighten flags"
      }
    ]
  },
  {
    "id": "compound-components-and-slots-typing",
    "title": "Typing Compound Components and Slots",
    "description": "Model parent-child relationships—Menu, Tabs, and List components with typed items and slot props.",
    "learningObjectives": [
      "Expose typed static subcomponents",
      "Type slot props and context",
      "Prevent invalid composition via types",
      "Support render props for advanced cases"
    ],
    "outline": [
      {
        "section": "Composition contracts",
        "topics": [
          "Static properties on components",
          "Context for coordination",
          "Discriminated item types"
        ],
        "examples": "Tabs with <Tabs.List> and <Tabs.Panel> typed by id.",
        "flow": "Define item types → wire context → enforce usage"
      },
      {
        "section": "Slots and render props",
        "topics": ["Children as function typing", "Element constraints"],
        "examples": "Menu slot receiving active boolean and props builder.",
        "flow": "Type slot → consume in items → tests"
      }
    ]
  },
  {
    "id": "render-props-and-hoc-alternatives",
    "title": "Render Props and HOC Alternatives",
    "description": "When generics beat HOCs—type render props for flexibility while keeping IntelliSense delightful.",
    "learningObjectives": [
      "Compare HOCs vs render props vs hooks",
      "Type render prop signatures with generics",
      "Prevent misuse with branded types",
      "Document patterns for teams"
    ],
    "outline": [
      {
        "section": "API design",
        "topics": ["Function-as-children typing", "Inferring render prop args"],
        "examples": "Pagination component exposing typed page, setPage, total.",
        "flow": "Design signature → implement → consumer DX"
      },
      {
        "section": "Safety rails",
        "topics": ["Brands and nominal-ish types", "Exhaustive handlers"],
        "examples": "Prevent mixing UserId with ProductId via brands.",
        "flow": "Define brands → enforce at call sites → compile-time wins"
      }
    ]
  },
  {
    "id": "use-layout-effect-and-effect-typing",
    "title": "useLayoutEffect vs useEffect: Typing and Pitfalls",
    "description": "Type effects that touch the DOM—avoid layout thrash and ensure cleanups are correctly captured and typed.",
    "learningObjectives": [
      "Type effect cleanups and dependencies",
      "Use layout effects only when necessary",
      "Model subscriptions with precise types",
      "Avoid stale closures via typed deps"
    ],
    "outline": [
      {
        "section": "Effect signatures",
        "topics": ["Cleanup return types", "Dependency typing"],
        "examples": "ResizeObserver in useEffect with typed cleanup.",
        "flow": "Implement effect → add types → test teardown"
      },
      {
        "section": "Layout work",
        "topics": ["Measurement patterns", "Ref reads and mutation typing"],
        "examples": "Tooltip positioner in useLayoutEffect with safe reads.",
        "flow": "Measure → update → confirm no flicker"
      }
    ]
  },
  {
    "id": "flushsync-and-imperative-dom",
    "title": "flushSync and Imperative DOM with Types",
    "description": "Coordinate with the DOM—type helpers that force sync updates for focus, measurement, and animations sparingly.",
    "learningObjectives": [
      "Type functions that sequence reads/writes",
      "Use flushSync in narrow cases",
      "Provide typed focus and selection utilities",
      "Test race conditions with fake timers"
    ],
    "outline": [
      {
        "section": "Sequencing utilities",
        "topics": ["requestAnimationFrame and timers", "Focus helpers typing"],
        "examples": "openModal → flushSync setOpen(true) → focus first input.",
        "flow": "Define helper → apply in component → verify in tests"
      },
      {
        "section": "Safety",
        "topics": ["Avoiding main thread blocks", "Fallback paths"],
        "examples": "Graceful degradation when focus target missing.",
        "flow": "Guard checks → error handling → CI tests"
      }
    ]
  },
  {
    "id": "internationalization-types",
    "title": "Internationalization with Type Safety",
    "description": "Localize without footguns—type message IDs, params, and locales so missing strings can’t slip through.",
    "learningObjectives": [
      "Define typed message catalogs",
      "Constrain translation params",
      "Type date/number formatting options",
      "Enforce coverage with TS and tests"
    ],
    "outline": [
      {
        "section": "Message IDs and params",
        "topics": ["as const catalogs", "satisfies for param maps"],
        "examples": "t('cart.items', { count }) with typed count param requirement.",
        "flow": "Define catalog → type t() → enforce usage"
      },
      {
        "section": "Formatting",
        "topics": ["Intl API types", "Locale-aware date/number"],
        "examples": "Price formatter returning branded CurrencyString.",
        "flow": "Create formatter → use in components → tests"
      }
    ]
  },
  {
    "id": "story-driven-development-with-types",
    "title": "Story-Driven Development with TypeScript",
    "description": "Use Storybook as a type lab—derive controls from props, test edge cases, and publish typed stories.",
    "learningObjectives": [
      "Infer controls from props types",
      "Write typed stories and meta",
      "Generate docs from types and JSDoc",
      "Validate prop unions via stories"
    ],
    "outline": [
      {
        "section": "Typed stories",
        "topics": ["Meta and StoryObj types", "Arg inference and constraints"],
        "examples": "Button story that restricts variant to union of variants.",
        "flow": "Define props → write stories → confirm controls"
      },
      {
        "section": "Docs",
        "topics": ["Autodocs from types", "Edge-case stories for unions"],
        "examples": "Variant matrix story generated from prop union.",
        "flow": "Generate → review → publish"
      }
    ]
  },
  {
    "id": "security-and-escaping-types",
    "title": "Security: Escaping, Sanitization, and Types",
    "description": "Keep XSS out—type dangerouslySetInnerHTML helpers, sanitize inputs, and model trusted vs untrusted strings.",
    "learningObjectives": [
      "Avoid unsafe HTML by default",
      "Model TrustedHTML and branded strings",
      "Type sanitization functions",
      "Constrain components that accept HTML"
    ],
    "outline": [
      {
        "section": "Trust boundaries",
        "topics": ["Branded types for sanitized HTML", "Factory functions to create TrustedHTML"],
        "examples": "SafeHtml brand returned from sanitize() required by Html component.",
        "flow": "Define brand → implement sanitizer → enforce usage"
      },
      {
        "section": "Components",
        "topics": ["dangerouslySetInnerHTML typing", "Escaping utilities"],
        "examples": "Html component that only accepts SafeHtml.",
        "flow": "Implement → attempt misuse → compile-time failure"
      }
    ]
  },
  {
    "id": "advanced-type-tricks-for-react",
    "title": "Advanced Type Tricks for React APIs",
    "description": "Pull out the big guns—satisfies, const assertions, conditional and mapped types that make UIs safer and nicer.",
    "learningObjectives": [
      "Use satisfies to validate constant objects",
      "Apply const assertions for literal inference",
      "Leverage conditional types for API ergonomics",
      "Build prop maps with exact keys enforced"
    ],
    "outline": [
      {
        "section": "Constant maps",
        "topics": ["Record vs object literals", "Key validation with satisfies"],
        "examples": "Variant-to-class map checked at compile time.",
        "flow": "Define map → enforce keys → consume in components"
      },
      {
        "section": "Conditional types",
        "topics": ["Prop exclusivity", "One-of unions"],
        "examples": "InputProps requiring either value/onChange or defaultValue.",
        "flow": "Model union → add helpers → tests"
      }
    ]
  },
  {
    "id": "exclusive-props-and-discriminated-unions",
    "title": "Exclusive Props and Discriminated Unions",
    "description": "Make invalid prop combos impossible—encode either-or props and narrow with discriminants cleanly.",
    "learningObjectives": [
      "Model mutually exclusive props with unions",
      "Use discriminant fields to guide narrowing",
      "Expose helpful error messages via types",
      "Write exhaustive switches to prevent fallthrough"
    ],
    "outline": [
      {
        "section": "Either-or props",
        "topics": ["XOR utility types", "Union narrowing in components"],
        "examples": "Avatar requiring either src or initials, not both.",
        "flow": "Define union → implement component → exhaustiveness check"
      },
      {
        "section": "Discriminants",
        "topics": ["kind field patterns", "Compiler help messages"],
        "examples": "Notification union driving render cases.",
        "flow": "Define union → render cases → never checker"
      }
    ]
  },
  {
    "id": "publishing-types-for-component-libraries",
    "title": "Publishing Types for Component Libraries",
    "description": "Ship library-quality types—d.ts output, stable public APIs, and semver discipline for React component kits.",
    "learningObjectives": [
      "Emit declaration files correctly",
      "Design stable public types and avoid breaking changes",
      "Document with TSDoc and extract docs",
      "Test consumer scenarios with tsd"
    ],
    "outline": [
      {
        "section": "Emission and packaging",
        "topics": [
          "types and exports fields",
          "sideEffects and treeshaking",
          "JSX namespace considerations"
        ],
        "examples": "Library build that produces ESM/CJS with d.ts and JSX compat.",
        "flow": "Configure build → verify d.ts → publish dry run"
      },
      {
        "section": "Consumer tests",
        "topics": ["tsd and sample app tests", "Semver guardrails"],
        "examples": "Lock ButtonProps across versions via type tests.",
        "flow": "Write tsd tests → run in CI → release checklist"
      }
    ]
  },
  {
    "id": "edge-ssr-and-runtime-types",
    "title": "Edge, SSR, and Runtime Types",
    "description": "Target multiple runtimes—align DOM vs Node types, edge constraints, and SSR data contracts with TypeScript.",
    "learningObjectives": [
      "Configure lib for DOM, DOM.Iterable, and Node",
      "Avoid Node-only APIs in edge/serverless",
      "Type SSR data hydration payloads",
      "Share types across server/client bundles"
    ],
    "outline": [
      {
        "section": "Lib targets",
        "topics": ["Multiple tsconfigs", "DOM vs Node globals"],
        "examples": "SSR project with server tsconfig and client tsconfig sharing types.",
        "flow": "Split configs → align libs → cross-check usage"
      },
      {
        "section": "Hydration payloads",
        "topics": ["Serializable value types", "Opaque branded IDs"],
        "examples": "Typed window.**DATA** bootstrap object validated on load.",
        "flow": "Define schema → serialize → parse in client"
      }
    ]
  },
  {
    "id": "devtools-and-type-driven-dx",
    "title": "DevTools and Type-Driven DX",
    "description": "Use types to supercharge DevTools—component labels, prop hints, and action logs that reflect your TypeScript models.",
    "learningObjectives": [
      "Set displayName from types for clearer trees",
      "Log actions with typed payload viewers",
      "Generate story controls from prop unions",
      "Correlate Profiler data with type contracts"
    ],
    "outline": [
      {
        "section": "Helpful labels",
        "topics": ["displayName and named functions", "Inferring labels from types"],
        "examples": "Auto-name memoized components consistently.",
        "flow": "Set labels → inspect DevTools → enforce conventions"
      },
      {
        "section": "Type-aware tooling",
        "topics": ["Story controls from unions", "Action payload viewers"],
        "examples": "Dev panel that shows discriminated action payloads.",
        "flow": "Define payload types → viewer → demo"
      }
    ]
  }
]
