[
  {
    "id": "understanding-reconciliation-react-19",
    "title": "Understanding Reconciliation in React 19",
    "description": "Demystify how React compares trees, chooses updates, and schedules work—then apply the rules to ship snappy, predictable UIs.",
    "learningObjectives": [
      "Explain how React matches elements by type and key and reuses state",
      "Differentiate node reuse, remounts, and DOM mutations",
      "Identify when key changes force remounts and state loss",
      "Use profiling signals to see reconciliation costs in practice",
      "Structure component trees to make diffs cheap and stable"
    ],
    "outline": [
      {
        "section": "Mental model of the diff",
        "topics": ["Top‑down comparison", "Type and key matching", "Child list reconciliation"],
        "examples": "Compare two lists of messages with stable vs changing keys.",
        "flow": "Concept → visual diff diagrams → console/DevTools verification"
      },
      {
        "section": "Remounts vs updates",
        "topics": ["What preserves state", "How a new key or type resets it"],
        "examples": "Tab panels toggled by index vs ID keys; preserving input focus.",
        "flow": "Demo → measure render and commit phases → checklist"
      },
      {
        "section": "Reconciliation and scheduling",
        "topics": ["Concurrent rendering impact", "Interruptible work and priorities"],
        "examples": "Throttle CPU and watch interrupted list renders.",
        "flow": "Experiment → profiling flamegraph → takeaways"
      },
      {
        "section": "Designing for predictable diffs",
        "topics": ["Stable component boundaries", "Avoiding shape‑shifting trees"],
        "examples": "Conditional wrappers that keep type/key stable.",
        "flow": "Refactor → verify with highlight updates → summary"
      }
    ]
  },
  {
    "id": "component-granularity-splitting",
    "title": "Component Granularity: Split Components Without Fragmenting Your Mind",
    "description": "Find the sweet spot between monoliths and confetti—split components to reduce re-renders while keeping code clear and testable.",
    "learningObjectives": [
      "Recognize symptoms of overly large components",
      "Use props boundaries to contain re-renders",
      "Choose between composition and context",
      "Measure granularity wins in DevTools"
    ],
    "outline": [
      {
        "section": "Why granularity matters",
        "topics": ["Render scope and invalidation", "Props as memoization boundaries"],
        "examples": "Refactor a dashboard card into header/body/footer pieces.",
        "flow": "Before profile → refactor → after profile → results"
      },
      {
        "section": "When to split",
        "topics": [
          "Heuristics: churny state, heavy visuals, expensive lists",
          "Avoiding premature fragmentation"
        ],
        "examples": "Product grid with filters and per‑item stats.",
        "flow": "Smells → plan → surgical split → verify"
      },
      {
        "section": "Patterns",
        "topics": [
          "Container/presentational",
          "Render props and slots",
          "Context for cross‑cutting concerns"
        ],
        "examples": "Theme and i18n as contexts with leaf components.",
        "flow": "Pattern tour → small demos → trade‑offs"
      }
    ]
  },
  {
    "id": "react-memo-react-19-and-compiler-era",
    "title": "React.memo in React 19 and the Compiler Era",
    "description": "Learn where React.memo still shines, when a compiler or bailouts make it redundant, and how to write fair areEqual checks.",
    "learningObjectives": [
      "Understand what React.memo skips and what it cannot",
      "Decide when memoization is redundant",
      "Author safe, cheap custom equality functions",
      "Measure the impact of memoization in real apps"
    ],
    "outline": [
      {
        "section": "How React.memo works",
        "topics": ["Props equality checks", "Interaction with context and state"],
        "examples": "Memoized list rows with stable row props.",
        "flow": "Concept → code → verify with render counts"
      },
      {
        "section": "When it’s unnecessary",
        "topics": ["Natural bailouts via component structure", "Compiler‑driven memoization"],
        "examples": "Remove memo from cheap leaf nodes and re‑measure.",
        "flow": "Hypothesis → experiment → conclusion"
      },
      {
        "section": "Custom areEqual",
        "topics": ["Cost of comparisons", "Avoiding deep‑compare traps"],
        "examples": "Domain‑specific compare for cart line items.",
        "flow": "Implement → micro‑bench → guardrails"
      }
    ]
  },
  {
    "id": "identity-stability-props",
    "title": "Identity Stability: Taming Objects, Arrays, and Functions as Props",
    "description": "Stop accidental re-renders from unstable references. Learn where identity matters and how to keep it stable without over-caching.",
    "learningObjectives": [
      "Spot referential instability and its cascade effects",
      "Stabilize callbacks and derived data only where needed",
      "Design prop shapes that minimize churn",
      "Profile to confirm fixes"
    ],
    "outline": [
      {
        "section": "Why identity changes trigger work",
        "topics": ["Shallow compare semantics", "Function identity and closures"],
        "examples": "Inline handlers vs memoized handlers in a list.",
        "flow": "Demonstration → diff analysis → fix"
      },
      {
        "section": "Practical stability",
        "topics": [
          "When to use useMemo/useCallback",
          "Passing event payloads instead of new objects"
        ],
        "examples": "Toolbar actions that pass IDs, not objects.",
        "flow": "Refactor → measure → checklist"
      }
    ]
  },
  {
    "id": "usememo-usecallback-in-react-19",
    "title": "useMemo and useCallback in React 19",
    "description": "Use memoization as a scalpel, not a sledgehammer—cache expensive work or stabilize identities where it truly pays off.",
    "learningObjectives": [
      "Differentiate compute caching vs identity stabilization",
      "Choose dependencies that reflect true inputs",
      "Avoid stale closures and memory bloat",
      "Verify wins with flamegraphs and timings"
    ],
    "outline": [
      {
        "section": "Two uses of memoization",
        "topics": ["Expensive compute vs referential equality", "Common misconceptions"],
        "examples": "Sorting and grouping a large dataset for a table.",
        "flow": "Explain → code → measure"
      },
      {
        "section": "Dependency management",
        "topics": ["Stable inputs", "Deriving deps from props/state"],
        "examples": "Memoized selector that tracks only needed fields.",
        "flow": "Identify → tighten deps → test"
      },
      {
        "section": "When not to memoize",
        "topics": ["Cheap work", "Rarely changing inputs", "GC and memory costs"],
        "examples": "Remove defensive memo hooks and compare FPS.",
        "flow": "A/B profile → rule of thumb"
      }
    ]
  },
  {
    "id": "custom-equality-checks-areequal",
    "title": "Custom Equality Checks with areEqual",
    "description": "Write domain-smart equality functions that avoid deep-compare traps and make memoized components both fast and correct.",
    "learningObjectives": [
      "Know when shallow compare is insufficient",
      "Design cheap, predictable comparisons",
      "Handle nested props without full deep equals",
      "Build test coverage for equality logic"
    ],
    "outline": [
      {
        "section": "Where custom equality helps",
        "topics": ["Dense prop objects", "Derived props vs raw inputs"],
        "examples": "Data grid row cells with derived formatting.",
        "flow": "Case study → design areEqual → tests"
      },
      {
        "section": "Cost discipline",
        "topics": ["Budget for comparisons", "Short‑circuit strategies"],
        "examples": "Compare IDs and versions before scanning arrays.",
        "flow": "Micro‑bench → refactor → verify"
      }
    ]
  },
  {
    "id": "avoiding-over-memoization",
    "title": "Avoiding Over‑Memoization",
    "description": "Stop paying rent for caches you never use. Learn to remove unnecessary memoization and let React do less work.",
    "learningObjectives": [
      "Identify negative ROI memoization",
      "Quantify memory and CPU overhead",
      "Replace memo with structural fixes",
      "Create a removal‑first optimization culture"
    ],
    "outline": [
      {
        "section": "Smells and symptoms",
        "topics": ["Memo everywhere anti‑pattern", "Stale data bugs"],
        "examples": "Audit a codebase with a ‘remove memo’ pass.",
        "flow": "Heuristics → removal → measure"
      },
      {
        "section": "Better alternatives",
        "topics": ["Granularity and prop pruning", "Server‑side computation"],
        "examples": "Move heavy derive to RSC or server endpoints.",
        "flow": "Refactor → profile → summary"
      }
    ]
  },
  {
    "id": "lifting-state-intelligently",
    "title": "Lifting State Intelligently",
    "description": "Lift state only when multiple peers truly need it. Contain churn and stop render ripples before they swamp your UI.",
    "learningObjectives": [
      "Decide the minimal shared owner for state",
      "Prevent unrelated subtrees from re-rendering",
      "Use selectors and contexts to narrow updates",
      "Refactor state without breaking UX"
    ],
    "outline": [
      {
        "section": "Finding the right owner",
        "topics": ["Data flow mapping", "Signals that state sits too high"],
        "examples": "Form wizard with per‑step local state vs global.",
        "flow": "Map → adjust → test re-renders"
      },
      {
        "section": "Containing updates",
        "topics": ["Selector contexts", "Event up, data down"],
        "examples": "Cart quantity updates that don’t re-render header.",
        "flow": "Implement → profile → iterate"
      }
    ]
  },
  {
    "id": "colocation-of-state",
    "title": "Colocation of State",
    "description": "Keep state near its consumers to reduce render storms, simplify data flow, and make components easier to reason about.",
    "learningObjectives": [
      "Detect state that drifted away from usage",
      "Move state down without duplicating truth",
      "Compose local state with server data",
      "Measure render containment improvements"
    ],
    "outline": [
      {
        "section": "What to colocate",
        "topics": ["Ephemeral UI details", "Visibility and input state"],
        "examples": "Accordion open/close state in item components.",
        "flow": "Audit → move → validate behavior"
      },
      {
        "section": "Balancing with shared state",
        "topics": ["When colocation fights global needs", "Extracting custom hooks"],
        "examples": "List filter state as a dedicated hook used by peers.",
        "flow": "Extract → reuse → profile"
      }
    ]
  },
  {
    "id": "derived-vs-stored-state",
    "title": "Derived vs Stored State",
    "description": "Store less, derive more. Compute on demand to avoid desyncs, extra memory, and unnecessary re-renders.",
    "learningObjectives": [
      "Identify duplicated state",
      "Replace stored derivations with selectors",
      "Use memoization to make derivations cheap",
      "Prevent desynchronization bugs"
    ],
    "outline": [
      {
        "section": "Spotting duplication",
        "topics": ["Mirrored flags and counters", "Cached aggregates"],
        "examples": "Cart subtotal derived from items vs stored separately.",
        "flow": "Find → replace with derive → test"
      },
      {
        "section": "Efficient derivations",
        "topics": ["Stable inputs for memo", "Incremental recompute"],
        "examples": "Group and sort messages with keyed memoization.",
        "flow": "Implement → benchmark → document"
      }
    ]
  },
  {
    "id": "separating-actions-from-state-two-contexts",
    "title": "Separating Actions from State with Two Contexts",
    "description": "Split read and write paths. Pass immutable state and stable actions to cut re-renders and improve testability.",
    "learningObjectives": [
      "Design read/write contexts for stability",
      "Keep actions identity-stable",
      "Avoid prop drilling without broad invalidation",
      "Refactor an app to two-context architecture"
    ],
    "outline": [
      {
        "section": "Two-context pattern",
        "topics": ["State context vs actions context", "Provider composition"],
        "examples": "Todo app with separate StateContext and ActionsContext.",
        "flow": "Introduce → wire up → validate"
      },
      {
        "section": "Performance gains",
        "topics": ["Selective subscription", "Stable callbacks"],
        "examples": "Typing in input doesn’t re-render list.",
        "flow": "Profile before/after → summarize"
      }
    ]
  },
  {
    "id": "key-stability-in-lists",
    "title": "Key Stability in Lists",
    "description": "Master keys to keep state, focus, and animations intact—no more mysterious remounts or janky list updates.",
    "learningObjectives": [
      "Explain how keys map children across renders",
      "Choose stable IDs over indices",
      "Handle reorder, insert, and delete correctly",
      "Diagnose key-related UX bugs"
    ],
    "outline": [
      {
        "section": "Keys 101",
        "topics": ["Identity mapping", "Index keys and their pitfalls"],
        "examples": "Editable list losing focus with index keys.",
        "flow": "Bad demo → fix → verify"
      },
      {
        "section": "Reorder and pagination",
        "topics": ["Stable keys across pages", "Merging server and client items"],
        "examples": "Infinite scroll feed with stable post IDs.",
        "flow": "Implement → test reorders → checklist"
      }
    ]
  },
  {
    "id": "windowing-and-virtualization",
    "title": "Windowing and Virtualization",
    "description": "Render only what users see. Use react-window to make 10,000-row lists fast without sacrificing UX or accessibility.",
    "learningObjectives": [
      "Explain the windowing trade‑offs",
      "Integrate react-window or react-virtualized",
      "Handle dynamic heights and sticky headers",
      "Preserve a11y and keyboard navigation"
    ],
    "outline": [
      {
        "section": "Why windowing",
        "topics": ["CPU/DOM costs of huge lists", "First paint and scroll jank"],
        "examples": "Mail inbox with 20k messages.",
        "flow": "Baseline → window → measure"
      },
      {
        "section": "Implementation details",
        "topics": ["Fixed vs variable size", "Item keying and memoization"],
        "examples": "VariableSizeList with avatars and multi-line text.",
        "flow": "Code → pitfalls → tests"
      }
    ]
  },
  {
    "id": "concurrent-react-scheduling",
    "title": "Concurrent React and Scheduling",
    "description": "Learn how React can pause and resume work to keep interactions smooth—design components that play nicely with the scheduler.",
    "learningObjectives": [
      "Describe interruptible rendering",
      "Design chunks of work that yield",
      "Use Suspense and transitions effectively",
      "Profile interaction responsiveness"
    ],
    "outline": [
      {
        "section": "Scheduler overview",
        "topics": ["Priorities and yielding", "Interaction tracing"],
        "examples": "Expensive filter during typing vs deferred update.",
        "flow": "Concept → demo → analyze"
      },
      {
        "section": "Compositional design",
        "topics": ["Small, independent subtrees", "Avoiding long synchronous work"],
        "examples": "Split chart rendering into progressive chunks.",
        "flow": "Refactor → test → checklist"
      }
    ]
  },
  {
    "id": "usetransition-and-starttransition",
    "title": "useTransition and startTransition",
    "description": "Mark non-urgent updates so urgent ones stay snappy—keep typing smooth while expensive UI catches up in the background.",
    "learningObjectives": [
      "Differentiate urgent vs non‑urgent updates",
      "Wrap expensive state changes in transitions",
      "Provide pending states for UX clarity",
      "Measure latency improvements"
    ],
    "outline": [
      {
        "section": "When to transition",
        "topics": ["Filtering, sorting, navigation", "Progress and spinners"],
        "examples": "Search results that update after typing settles.",
        "flow": "Identify → wrap with transition → UX polish"
      },
      {
        "section": "Gotchas",
        "topics": ["Avoiding starvation", "Interplay with Suspense"],
        "examples": "Ensure pending UI renders immediately.",
        "flow": "Pitfalls → fixes → tests"
      }
    ]
  },
  {
    "id": "suspense-for-data-fetching",
    "title": "Suspense for Data Fetching",
    "description": "Stream UI progressively instead of blocking on everything—compose boundaries that keep pages interactive and informative.",
    "learningObjectives": [
      "Add Suspense boundaries with useful fallbacks",
      "Combine Suspense with transitions",
      "Stream server-rendered content progressively",
      "Handle errors with error boundaries"
    ],
    "outline": [
      {
        "section": "Suspense model",
        "topics": ["What suspends and why", "Fallback design"],
        "examples": "Skeletons for product cards while details stream.",
        "flow": "Explain → code → UX examples"
      },
      {
        "section": "End‑to‑end streaming",
        "topics": ["SSR with streaming chunks", "Selective hydration interplay"],
        "examples": "Server‑rendered list with incremental details.",
        "flow": "Server → client → measure TTI"
      }
    ]
  },
  {
    "id": "react-server-components-rsc",
    "title": "React Server Components",
    "description": "Move heavy work to the server and hydrate only where needed—ship less JS and free the main thread for interactions.",
    "learningObjectives": [
      "Explain the client/server boundary and the RSC tree",
      "Choose what runs on server vs client",
      "Fetch and cache data on the server",
      "Integrate RSC in modern app frameworks"
    ],
    "outline": [
      {
        "section": "RSC fundamentals",
        "topics": ["Server vs client components", "Crossing the boundary"],
        "examples": "Product page with server‑rendered details, client cart.",
        "flow": "Architecture → code → run"
      },
      {
        "section": "Data and caching",
        "topics": ["Server fetch patterns", "Stable resource identity"],
        "examples": "Per‑route caches for catalog queries.",
        "flow": "Implement → validate → profile"
      }
    ]
  },
  {
    "id": "selective-hydration-react-19",
    "title": "Selective Hydration in Modern React Apps",
    "description": "Hydrate what matters first. Prioritize above‑the‑fold work so pages feel interactive even while the rest continues to load.",
    "learningObjectives": [
      "Describe hydration phases and priorities",
      "Structure pages for incremental hydration",
      "Design good fallbacks for late regions",
      "Measure hydrate costs and regressions"
    ],
    "outline": [
      {
        "section": "Hydration basics",
        "topics": ["From HTML to live components", "Blocking vs incremental hydration"],
        "examples": "News article hydrates header/CTA first; comments later.",
        "flow": "Concept → network throttle → observe"
      },
      {
        "section": "Shaping the tree",
        "topics": ["Boundary placement", "Splitting interactive islands"],
        "examples": "Islands for nav, comments, and ads.",
        "flow": "Refactor → profile → checklist"
      }
    ]
  },
  {
    "id": "code-splitting-and-lazy-loading",
    "title": "Code‑Splitting and Lazy Loading",
    "description": "Load less JavaScript upfront. Split routes, components, and vendors to speed first paint and boost Core Web Vitals.",
    "learningObjectives": [
      "Identify good split points",
      "Use dynamic import and React.lazy",
      "Preload critical chunks without double load",
      "Validate with bundle analyzers"
    ],
    "outline": [
      {
        "section": "Finding split points",
        "topics": ["Routes vs components", "Above‑the‑fold priorities"],
        "examples": "Split admin panel and heavy charts.",
        "flow": "Audit → plan → implement"
      },
      {
        "section": "Lazy and preloading",
        "topics": ["Suspense boundaries", "Preload vs prefetch"],
        "examples": "Preload the likely next route on hover.",
        "flow": "Code → measure → refine"
      }
    ]
  },
  {
    "id": "avoiding-unnecessary-dependencies",
    "title": "Avoiding Unnecessary Dependencies",
    "description": "Trim the fat. Replace heavy libraries with native APIs or lighter alts and lean on tree‑shaking to cut bundle size.",
    "learningObjectives": [
      "Spot heavyweight deps and dead code",
      "Use tree‑shaking‑friendly imports",
      "Swap to lighter equivalents",
      "Prevent regressions with CI size budgets"
    ],
    "outline": [
      {
        "section": "Finding bloat",
        "topics": ["Bundle analyzer workflows", "Common culprits: date, util, UI kits"],
        "examples": "Replace moment.js with date‑fns/native Intl.",
        "flow": "Analyze → replace → verify size"
      },
      {
        "section": "Tree‑shaking hygiene",
        "topics": ["ES modules only", "Named imports over namespace"],
        "examples": "Switch `import _ from 'lodash'` to pick utilities.",
        "flow": "Refactor → ensure shake → CI budget"
      }
    ]
  },
  {
    "id": "measuring-performance-with-real-tools",
    "title": "Measuring Performance with Real Tools",
    "description": "Stop guessing. Use React DevTools, Chrome Performance, and flamegraphs to find real bottlenecks and prove improvements.",
    "learningObjectives": [
      "Profile component renders and commits",
      "Interpret flamegraphs and timings",
      "Design fair synthetic benchmarks",
      "Track Web Vitals in CI and production"
    ],
    "outline": [
      {
        "section": "React DevTools Profiler",
        "topics": ["Render counts and commit times", "Why did this render?"],
        "examples": "Investigate a chat thread re-render storm.",
        "flow": "Record → analyze → fix"
      },
      {
        "section": "Chrome Performance and Lighthouse",
        "topics": ["Main‑thread breakdown", "FID/TTI/INP basics"],
        "examples": "Profile typing latency under CPU throttle.",
        "flow": "Capture → compare → document"
      }
    ]
  },
  {
    "id": "optimizing-server-side-rendering",
    "title": "Optimizing Server‑Side Rendering",
    "description": "Speed up SSR with streaming, caching, and smarter data fetching—reduce time‑to‑first‑byte and hydrate faster.",
    "learningObjectives": [
      "Use streaming to reduce TTFB",
      "Cache template and data effectively",
      "Avoid waterfalls with parallel fetches",
      "Balance SSR vs CSR vs RSC"
    ],
    "outline": [
      {
        "section": "SSR performance levers",
        "topics": ["Streaming and partial responses", "CDN and edge caching"],
        "examples": "Cache HTML shell; stream product details later.",
        "flow": "Plan → implement → test"
      },
      {
        "section": "Data orchestration",
        "topics": ["Batching and parallelization", "Avoiding N+1 fetches"],
        "examples": "Consolidate GraphQL queries server‑side.",
        "flow": "Refactor → observe → iterate"
      }
    ]
  },
  {
    "id": "the-use-hook",
    "title": "The use() Hook",
    "description": "Simplify async and context consumption by letting components ‘use’ resources directly, with Suspense driving the UI flow.",
    "learningObjectives": [
      "Consume promises and contexts with use()",
      "Coordinate with Suspense boundaries",
      "Handle errors and loading states cleanly",
      "Adopt patterns that keep components simple"
    ],
    "outline": [
      {
        "section": "Ergonomics of use()",
        "topics": ["Resolving promises during render", "Interacting with caches"],
        "examples": "User profile fetch with Suspense fallback.",
        "flow": "Concept → code → UX polish"
      },
      {
        "section": "Error and loading handling",
        "topics": ["Error boundaries", "Progressive disclosure"],
        "examples": "Resource fails and recovers with retries.",
        "flow": "Scenarios → patterns → tests"
      }
    ]
  },
  {
    "id": "flushsync-in-react-dom",
    "title": "flushSync: Forcing Synchronous Flushes Carefully",
    "description": "Force React to flush updates now—use sparingly to coordinate with imperative APIs like focus, measurements, and animations.",
    "learningObjectives": [
      "Understand what flushSync does",
      "Coordinate DOM reads/writes safely",
      "Avoid long blocks on the main thread",
      "Test edge cases under concurrency"
    ],
    "outline": [
      {
        "section": "When synchronous is necessary",
        "topics": ["Measuring layout", "Focus management"],
        "examples": "Focus input right after showing a modal.",
        "flow": "Show problem → apply flush → validate"
      },
      {
        "section": "Hazards and limits",
        "topics": ["Blocking interactions", "Batched updates and priorities"],
        "examples": "Overuse causing jank in a grid editor.",
        "flow": "Pitfalls → guardrails → checklist"
      }
    ]
  },
  {
    "id": "resource-preloading-apis",
    "title": "Resource Preloading APIs",
    "description": "Prime the cache for what users will do next—preload, prefetch, and preinit without double‑loading or hurting metrics.",
    "learningObjectives": [
      "Differentiate preload, prefetch, and preconnect",
      "Preinit modules and fonts correctly",
      "Avoid duplicate fetches with hints",
      "Measure real‑world impact"
    ],
    "outline": [
      {
        "section": "Choosing the right hint",
        "topics": ["Critical vs speculative resources", "Priority management"],
        "examples": "Preload hero image; prefetch likely next route.",
        "flow": "Audit → apply hints → verify network"
      },
      {
        "section": "Integration with bundlers",
        "topics": ["Link hints generation", "Avoiding duplication"],
        "examples": "Emit link headers from server for SSR pages.",
        "flow": "Configure → deploy → measure"
      }
    ]
  },
  {
    "id": "react-cache-api",
    "title": "The cache() API",
    "description": "Stabilize and dedupe expensive work across requests and renders—use cache() to turn pure functions into shared resources.",
    "learningObjectives": [
      "Create cached resources safely",
      "Choose cache keys and lifetimes",
      "Invalidate and refresh data correctly",
      "Combine with Suspense and use()"
    ],
    "outline": [
      {
        "section": "Caching primitives",
        "topics": ["Resource identity", "Scope and lifetime"],
        "examples": "Cache product lookups keyed by locale.",
        "flow": "Design → implement → test"
      },
      {
        "section": "Invalidation",
        "topics": ["Staleness and revalidation", "Mutation flows"],
        "examples": "Invalidate after checkout updates inventory.",
        "flow": "Event → invalidate → observe"
      }
    ]
  },
  {
    "id": "useactionstate-performance",
    "title": "useActionState and Actions: Performance Patterns",
    "description": "Handle mutations with fewer renders and clearer UX—useActionState coordinates pending, success, and error states efficiently.",
    "learningObjectives": [
      "Model mutation lifecycles with actions",
      "Represent pending and optimistic UI cleanly",
      "Avoid global spinner traps",
      "Measure latency and re-render counts"
    ],
    "outline": [
      {
        "section": "Actions overview",
        "topics": ["Submitting forms and commands", "Return values and errors"],
        "examples": "Checkout button with optimistic inventory update.",
        "flow": "Wire → test → refine"
      },
      {
        "section": "Optimistic UX",
        "topics": ["Rollback on failure", "Granular pending indicators"],
        "examples": "Like button with immediate toggle and retry.",
        "flow": "Implement → failure drills → metrics"
      }
    ]
  },
  {
    "id": "usedeferredvalue-patterns",
    "title": "useDeferredValue Patterns",
    "description": "Keep typing fluid by deferring expensive derived values. Pair with transitions and memoization for silky search UIs.",
    "learningObjectives": [
      "Defer non‑urgent derived work",
      "Coordinate with transitions",
      "Prevent stale UI glitches",
      "Measure responsiveness gains"
    ],
    "outline": [
      {
        "section": "Defer the right things",
        "topics": ["Large filters, sorts, and layouts", "Avoid deferring essential feedback"],
        "examples": "Defer filtered result list while input stays instant.",
        "flow": "Baseline → add deferral → compare"
      },
      {
        "section": "Composition",
        "topics": ["Deferred values inside memoized selectors", "Interaction with Suspense"],
        "examples": "Search box + deferred heavy table render.",
        "flow": "Compose → test → pitfalls"
      }
    ]
  },
  {
    "id": "uselayouteffect-performance",
    "title": "Performance Characteristics of useLayoutEffect",
    "description": "Know when layout effects are necessary—and when they block paint. Prefer passive effects and measure before forcing sync work.",
    "learningObjectives": [
      "Differentiate layout vs passive effects",
      "Avoid layout thrash and reflows",
      "Coordinate measurements and mutations",
      "Migrate layout logic where possible"
    ],
    "outline": [
      {
        "section": "What blocks paint",
        "topics": ["Synchronous layout reads", "Effect timing and priorities"],
        "examples": "Measure tooltip position without jank.",
        "flow": "Bad pattern → improved pattern → verify"
      },
      {
        "section": "Safer alternatives",
        "topics": ["ResizeObserver and IntersectionObserver", "requestAnimationFrame sequencing"],
        "examples": "Use rAF to batch post‑paint mutations.",
        "flow": "Refactor → test → checklist"
      }
    ]
  },
  {
    "id": "swc-speedy-web-compiler",
    "title": "Speedy Web Compiler (SWC) for React Apps",
    "description": "Compile and minify at warp speed. Configure SWC to speed local builds and keep production bundles lean and modern.",
    "learningObjectives": [
      "Explain SWC’s role in the toolchain",
      "Tune transforms and minification",
      "Enable fast refresh and source maps",
      "Compare output size and build times"
    ],
    "outline": [
      {
        "section": "Compiler basics",
        "topics": ["Transpile, minify, and tree‑shake", "ES features and targets"],
        "examples": "Switch Babel config to SWC and measure.",
        "flow": "Setup → build → benchmark"
      },
      {
        "section": "Optimizations",
        "topics": ["Relaxed dev transforms", "Aggressive prod minification"],
        "examples": "Tune react refresh and module aliasing.",
        "flow": "Config → iterate → document"
      }
    ]
  }
]
